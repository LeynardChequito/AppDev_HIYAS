{"ast":null,"code":"import { createDirective } from '../utils/private/create.js';\nimport { isDeepEqual } from '../utils/is.js';\nimport getSSRProps from '../utils/private/noop-ssr-directive-transform.js';\nconst defaultCfg = {\n  threshold: 0,\n  root: null,\n  rootMargin: '0px'\n};\nfunction update(el, ctx, value) {\n  let handler, cfg, changed;\n  if (typeof value === 'function') {\n    handler = value;\n    cfg = defaultCfg;\n    changed = ctx.cfg === void 0;\n  } else {\n    handler = value.handler;\n    cfg = Object.assign({}, defaultCfg, value.cfg);\n    changed = ctx.cfg === void 0 || isDeepEqual(ctx.cfg, cfg) === false;\n  }\n  if (ctx.handler !== handler) {\n    ctx.handler = handler;\n  }\n  if (changed === true) {\n    ctx.cfg = cfg;\n    ctx.observer !== void 0 && ctx.observer.unobserve(el);\n    ctx.observer = new IntersectionObserver(([entry]) => {\n      if (typeof ctx.handler === 'function') {\n        // if observed element is part of a vue transition\n        // then we need to be careful...\n        if (entry.rootBounds === null && document.body.contains(el) === true) {\n          ctx.observer.unobserve(el);\n          ctx.observer.observe(el);\n          return;\n        }\n        const res = ctx.handler(entry, ctx.observer);\n        if (res === false || ctx.once === true && entry.isIntersecting === true) {\n          destroy(el);\n        }\n      }\n    }, cfg);\n    ctx.observer.observe(el);\n  }\n}\nfunction destroy(el) {\n  const ctx = el.__qvisible;\n  if (ctx !== void 0) {\n    ctx.observer !== void 0 && ctx.observer.unobserve(el);\n    delete el.__qvisible;\n  }\n}\nexport default createDirective(__QUASAR_SSR_SERVER__ ? {\n  name: 'intersection',\n  getSSRProps\n} : {\n  name: 'intersection',\n  mounted(el, {\n    modifiers,\n    value\n  }) {\n    const ctx = {\n      once: modifiers.once === true\n    };\n    update(el, ctx, value);\n    el.__qvisible = ctx;\n  },\n  updated(el, binding) {\n    const ctx = el.__qvisible;\n    ctx !== void 0 && update(el, ctx, binding.value);\n  },\n  beforeUnmount: destroy\n});","map":{"version":3,"names":["createDirective","isDeepEqual","getSSRProps","defaultCfg","threshold","root","rootMargin","update","el","ctx","value","handler","cfg","changed","Object","assign","observer","unobserve","IntersectionObserver","entry","rootBounds","document","body","contains","observe","res","once","isIntersecting","destroy","__qvisible","__QUASAR_SSR_SERVER__","name","mounted","modifiers","updated","binding","beforeUnmount"],"sources":["C:/Users/user/OneDrive/Desktop/HiyasProject/node_modules/quasar/src/directives/Intersection.js"],"sourcesContent":["import { createDirective } from '../utils/private/create.js'\nimport { isDeepEqual } from '../utils/is.js'\nimport getSSRProps from '../utils/private/noop-ssr-directive-transform.js'\n\nconst defaultCfg = {\n  threshold: 0,\n  root: null,\n  rootMargin: '0px'\n}\n\nfunction update (el, ctx, value) {\n  let handler, cfg, changed\n\n  if (typeof value === 'function') {\n    handler = value\n    cfg = defaultCfg\n    changed = ctx.cfg === void 0\n  }\n  else {\n    handler = value.handler\n    cfg = Object.assign({}, defaultCfg, value.cfg)\n    changed = ctx.cfg === void 0 || isDeepEqual(ctx.cfg, cfg) === false\n  }\n\n  if (ctx.handler !== handler) {\n    ctx.handler = handler\n  }\n\n  if (changed === true) {\n    ctx.cfg = cfg\n    ctx.observer !== void 0 && ctx.observer.unobserve(el)\n\n    ctx.observer = new IntersectionObserver(([ entry ]) => {\n      if (typeof ctx.handler === 'function') {\n        // if observed element is part of a vue transition\n        // then we need to be careful...\n        if (\n          entry.rootBounds === null\n          && document.body.contains(el) === true\n        ) {\n          ctx.observer.unobserve(el)\n          ctx.observer.observe(el)\n          return\n        }\n\n        const res = ctx.handler(entry, ctx.observer)\n\n        if (\n          res === false\n          || (ctx.once === true && entry.isIntersecting === true)\n        ) {\n          destroy(el)\n        }\n      }\n    }, cfg)\n\n    ctx.observer.observe(el)\n  }\n}\n\nfunction destroy (el) {\n  const ctx = el.__qvisible\n\n  if (ctx !== void 0) {\n    ctx.observer !== void 0 && ctx.observer.unobserve(el)\n    delete el.__qvisible\n  }\n}\n\nexport default createDirective(__QUASAR_SSR_SERVER__\n  ? { name: 'intersection', getSSRProps }\n  : {\n      name: 'intersection',\n\n      mounted (el, { modifiers, value }) {\n        const ctx = {\n          once: modifiers.once === true\n        }\n\n        update(el, ctx, value)\n\n        el.__qvisible = ctx\n      },\n\n      updated (el, binding) {\n        const ctx = el.__qvisible\n        ctx !== void 0 && update(el, ctx, binding.value)\n      },\n\n      beforeUnmount: destroy\n    }\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}